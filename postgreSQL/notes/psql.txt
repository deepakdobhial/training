---------------------PostgresSQL (version 14.1)-------------------------------- (https://www.postgresqltutorial.com)

1) Connect to the PostgreSQL database server via psql
	
	When you installed PostgreSQL, the installation process created a user account called postgres associated with the default postgres 		role.
	
	i) switch over to the postgres account on your server
	
		syntax: $ sudo -i -u postgres
		output: [sudo] password for beryl: type password
		
	ii) Access the PostgreSQL 
	
		syntax: psql or psql -U postgres -h localhost
		output: postgres=# 
		
2) Quit the PostgreSQL
	
	i) syntax: postgres=# \q (This above command will bring you back to the postgres Linux command prompt.)
	   output: postgres@beryl-HP-ProBook-6460b: pwd
		/var/lib/postgresql

	ii) syntax: postgres@beryl-HP-ProBook-6460b:exit  (To return to your regular system user)
	    output: logout 
	    
	 
	 
3) Load the sample database

	i) First, switch over the postgres account using the following command:

		syntax: $ sudo -i -u postgres
		
	ii) download the sample database using the curl tool:
		syntax: $ curl -O https://sp.postgresqltutorial.com/wp-content/uploads/2019/05/dvdrental.zip
		
	iii) Third, unzip the dvdrental.zip file to get the dvdrental.tar file:

		syntax: $ unzip dvdrental.zip
		
	iv)Access the PostgreSQL using the psql tool:

		syntax: $ psql
			
	v) Create the dvdrental database using the CREATE DATABASE statement:

		syntax: postgres=# create database dvdrental;
			
	vi) Quit the psql by using the \q command:

		syntax: postgres=# \q
	vii) Use the pg_restore tool to restore the dvdrental database:

		syntax: $ pg_restore --dbname=dvdrental --verbose dvdrental.tar
		
	viii) Access PostgreSQL database server again using psql:

		syntax: $ psql
			
	ix) Switch to the dvdental database:

		syntax: postgres=# \c dvdrental
			
			Now, you’re connected to the dvdrental database:

			dvdrental=#
			dvdrental=# select count(*) from film;
			
			Here is the output:

			count
			-------
			1000
			(1 row)
			
			
4) check version 

	syntax: postgres=# select version();
	output: show version
	
5) -------------------------------------------Data Types--------------------------------------------------------

	5.1)  Boolean type- (Three values: true, false and NULL, storing byte- one byte, abbreviated - BOOL)
	
		5.1.1) valid literal values for TRUE and FALSE   
		
					True	False		NULL
					true	false		Space
					‘t’	‘f ‘		
					‘true’	‘false’	
					‘y’	‘n’
					‘yes’	‘no’
					‘1’	‘0’
					
	5.2) Character types - i)  CHARACTER(n) or CHAR(n), 
				ii) CHARACTER VARYINGING(n) or VARCHAR(n), 
				ii) TEXT                                   ( n is a positive integer.)
	

				Character Types			       Description
				---------------------------------------------------------------------
				CHARACTER VARYING(n), VARCHAR(n)	variable-length with length limit
				CHARACTER(n), CHAR(n)			fixed-length, blank padded	
				TEXT, VARCHAR				variable unlimited length
							
					
		
		
		
		
	5.3) Numeric type - i) integer
			    ii) floating-point numbers
		
		
			i) integer- 
					 Name		Storage Size	   Min		   		Max
					 ----------------------------------------------------------------------
					 SMALLINT	2 bytes	-32,768			+32,767
					 INTEGER(INT)	4 bytes	-2,147,483,648			+2,147,483,647
					 BIGINT	8 bytes	-9,223,372,036,854,775,808	+9,223,372,036,854,775,807
					 
					 
					 
			ii)Decimal(p,e)-  decimal 	variable 	user-specified       up to 131072 digits before the decimal point;  
									precision,exact      up to 16383 digits after the decimal point 
			
			
		        iii)numeric -	numeric 	variable 	user-specified       up to 131072 digits before the decimal point; 
		        						precision,exact      up to 16383 digits after the decimal point
		        
		        iv) float(in exact)
			iv) real	real 	         4 bytes 	variable-precision,inexact 	6 decimal digits precision
			
			v) double       double          8 bytes        variable-precision,inexact     15 decimal digits precision
			  Precision     precision	 		 	


	Auto_increment - vi) serial- 	smallserial 	2 bytes 	small autoincrementing integer 	1 to 32767
			                serial 	4 bytes 	autoincrementing integer 	        1 to 2147483647
					bigserial 	8 bytes 	large autoincrementing integer 	1 to 9223372036854775807


	5.4) Monetary Types- The money type stores a currency amount with a fixed fractional precision. Values of the numeric, int, and 					bigint data types can be cast to money. Using Floating point numbers is not recommended to handle money 					due to the potential for rounding errors.

					Name 	Storage Size 	Description 	                     Range
					money 	8 bytes 	currency amount 	-92233720368547758.08 to +92233720368547758.07

	5.5) Date/Time Types- 
	
	
	Name 	           Description 	  Storage Size 	  Low Value 	   High Value 	        Resolution
	-------------------------------------------------------------------------------------------------------------------
	
	1) Date-  used to store the date values. (YYYY-MM-DD)  (4 bytes and range- 1000-01-01 to 9999-12-31)
	
			
	Syntax: mydatabase=# alter table emp
		mydatabase-# add column joining_date Date not null default current_date;
		ALTER TABLE

	
	
	2) Time: which stores the Time of days values.  (8 bytes of storage,  6 digits of precision and range- 00:00:00 to 24:00:00)
	
	i) without precision Time format -         HH:MM     
						    HH:MM:SS  
						    HHMMSS 
						    
	ii) With precision Time format - 	    MM:SS.pppppp   (12:10:12.123654)   
						    HH:MM:SS.pppppp  
						    HHMMSS.pppppp   
	
	
				syntax: alter table emp add column logout time;
				
				
	
	
	3) TIME with time zone type (timetz) - (12 bytes, which allow us to store a time value with the time zone from 00:00:00+1459 to 														24:00:00-1459 range.)
	
		
	
	
	4) Timestamp - store both TIME and DATE values. 
	
			I) TIMESTAMP - The timestamp data type is used without time zone one
			
			II) Timestamptz: The timestamptz data type is used with a time zone.
			
	
	
	5) Interval - used to store and deploy Time in years, months, days, hours, minutes, seconds, etc. And the months and days values 				are integers values, whereas the second's field can be the fractions values.
			(16 bytes, -178000000 years to 178000000 years.)
		
	syntax: 	
	
	
	
	

		
		
6) clear screen from psql
			syntax: \! clear     (use linux commands)		
			
		
		
7) Create and Drop database

	7.1) create database

		i) Syntax: postgres@beryl-HP-ProBook-6460b: createdb databasename (using command line)
			
				or
				
		ii) postgres=# create database databasename;
		
		
		
	7.2) drop database
		
		i) Syntax: postgres@beryl-HP-ProBook-6460b: dropdb databasename
			    				     dropdb -h localhost -p 5432 -U postgress testdb  (using command line)
			
				or
				
		ii) postgres=# drop database [if exists] databasename;
		
		
		
8)  List all database 
	
		syntax: \l or \l databasename;
		
		
9) select database (switch database)
	
		syntax: \c databasename;
		
		syntax: psql -h localhost -p 5432 -U postgres databasename   (using command line)
			
			databasename#
			
			
10)  Alter database (rename database)

		syntax: alter database databasename rename to newname;
		
11) Create Table

		syntax: create table [if not exists] tablename(
			column1 datatype column_constraint,
			column2 datatype column_constraint,
			column3 datatype column_constraint,
			table_constraints
			);
			
			
12) show table lists in database

		syntax: \d or \dt  (list all tables)
		
13)table structure (Describe) 

		syntx: \d tablename;
		
14) Drop a table

		syntax: drop table tablename1,tablename2;
		
15)  Alter table (rename table)

		syntax: Alter table tablename rename to newname;
		
16) Insert into table

		syntax: insert into tablename
			(column1, column2, column3,...columnN)
		 VALUES (value1, value2, value3,...valueN);		
		
17) Select from table

		syntax: select * or column1,column2 from tablename; 
		
		
		
		
18) update contents in table

		syntax: UPDATE table_name
			SET column1 = value1, column2 = value2...., columnN = valueN
			WHERE [condition];
					
19) Delete/Truncate contents from table

		syntax: DELETE FROM table_name
			WHERE [condition];
			
			
	------------------------------------------------------------------------------		
		syntax:     TRUNCATE TABLE table_name; 
   			   [ RESTART IDENTITY | CONTINUE IDENTITY ] [ CASCADE | RESTRICT ]  
	-----------------------------------------------------------------------------------
	
			
20) Alter table 

		20.1) Add column - syntax:        ALTER TABLE table_name  
   					    	   ADD COLUMN new_column_name data_type,
   					           ADD COLUMN new_column_name data_type;  
   					     	
   		20.2) i) DROP COLUMN - syntax:       ALTER TABLE table_name   
    						      DROP COLUMN column_name;  
		    
		      ii) Removing those columns and all its connected objects

    				syntax: ALTER TABLE table_name  
    				      	DROP COLUMN column_name CASCADE;  	
   			        	
		      iii)     ALTER TABLE table_name   
		       	DROP COLUMN IF EXISTS column_name;  
			
		      iv)     ALTER TABLE table_name  
		      	      DROP COLUMN column_name_1,  
			      DROP COLUMN column_name_2;
			      
	     	20.3) CHANGE DATA TYPE OF A COLUMN
	     			
	     			Syntax:     ALTER TABLE table_name  
					    ALTER COLUMN column_name_1 SET DATA TYPE OR TYPE new_data_type,  
					    ALTER COLUMN column_name_2 SET DATA TYPE OR TYPE new_data_type;   
	     	  
		20.4) RENAME COLUMN 
			
				Syntax:     ALTER TABLE table_name   
    					    RENAME COLUMN column_name TO new_column_name;  (one at a time)
    					    
         	20.5) Set a default value for the column.
         	
         			Syntax:     	ALTER TABLE table_name 
					    	ALTER COLUMN column_name 
					    	[SET DEFAULT give value | DROP DEFAULT];
		
		
		
		
		20.6) Add a constraint to a column
		
				syntax: 	ALTER TABLE table_name 
						ADD CONSTRAINT constraint_name constraint_definition;
						
		20.7) Drop Unique Constraint

				Syntax:	ALTER TABLE table_name
						DROP CONSTRAINT constraint_name;
						
						
21) Clause: ( From > Where > group by > having > select > Distinct > Order by > Limit)
	      -----------------------------------------------------------------------
	      		
		21.1) Where : - The WHERE condition is used to describe a condition while we get data from a table or a Join various 					tables. It is commonly used with SELECT, UPDATE, and DELETE commands to filter the output. It returns the 					exact result only when the condition is fulfilled.
		
		
		
				syntax: SELECT column1, column2, ..... columnN    
					FROM table_name    
					WHERE [search_condition]    
					
				
				e.g. 	select name, id from teachers where id=1;
		
				output:     name    | id 
					------------+----
					 Manju dass |  2
					 Manoj      |  2
					(2 rows)
					
						
				e.g.	select name, id,salary from teachers where salary>10000;
				
				Output: name  | id | salary 
					-------+----+--------
					 Manoj |  1 |  50000
					 Manoj |  2 |  50000
					(2 rows)
					
		21.2) GROUP BY - GROUP BY clause is used in collaboration with the SELECT statement to group together those rows in a 						table that have identical data. This is done to eliminate redundancy in the output and/or compute 						aggregates that apply to these groups.
					
		
		
				syntax: SELECT column-list    
					FROM table_name    
					WHERE [conditions ]    
					GROUP BY column1, column2....columnN    
					ORDER BY column1, column2....columnN    
					
					
				e.g.	select id, name from teachers group by name, id;
					
					select name, count(salary) from teachers group by name;
					
				output:     name    | count 
					------------+-------
					 Manju dass |     1
					 ritu       |     1
					 Manoj      |     2
					(3 rows)
					
				e.g. 	# select name, sum(salary) from teachers group by name;
				
					    name    |  sum   
			       output:	------------+--------
					 Manju dass |  10000
					 ritu       |  10000
					 Manoj      | 100000
					(3 rows)

						
					
		21.3) HAVING : - HAVING clause places conditions on groups created by the GROUP BY clause.
				  it is regularly used with the GROUP BY clause to filter groups or aggregates based on a detailed 					  condition.	
				
				syntax: SELECT column1, column2
					FROM table1, table2
					WHERE [ conditions ]
					GROUP BY column1, column2
					HAVING [ conditions ]
					ORDER BY column1, column2
					
					
				e.g.   select name,id,salary from teachers group by name,id,salary having max(salary)<=10000;
				output:     name    | id | salary 
					------------+----+--------
					 ritu       |  3 |  10000
					 Manju dass |  2 |  10000
					 
					 
		21.4) DISTINCT:- Used in conjunction with SELECT statement to eliminate all the duplicate records and fetching only 					   unique records.
		
		
				syntax: SELECT DISTINCT name FROM COMPANY;
		

			    	  --  the combination of values in both column1,column2...columnN will be used for evaluating the 				      duplicate.
				
				syntax: SELECT DISTINCT column1, column2,.....columnN
					FROM table_name
					WHERE [condition]
					
					combination values - select  gender,name from teachers ;
								 gender |    name    
								--------+------------
								 M      | Manoj
								 M      | Manoj
								 M      | Ram
								 F      | ritu
								 F      | Manju dass
								(5 rows)

					
					
					
				e.g.  select distinct gender,name from teachers; (distinct based combination values)
					 gender |    name    
					--------+------------
					 M      | Manoj
					 M      | Ram
					 F      | ritu
					 F      | Manju dass
					(4 rows)
					
					
			DISTINCT ON : - sorts the result set by the  bcolor and  fcolor, and then for each group of duplicates, it keeps 						the first row in the returned result set.
			 
			Without distinct On -	 mydatabase=# select gender,name,id from teachers order by gender,name;
						 gender |    name    | id 
						--------+------------+----
						 F      | Manju dass |  5
						 F      | ritu       |  3
						 M      | Manoj      |  1
						 M      | Manoj      |  2
						 M      | Ram        |  4
						(5 rows)

			With distinct On:       mydatabase=# select distinct on(gender) gender,name,id from teachers order by gender,name;
						 gender |    name    | id 
						--------+------------+----
						 F      | Manju dass |  5
						 M      | Manoj      |  1
						(2 rows)


		
		21.5) ORDER BY - sort the data in ascending or descending order, based on one or more columns. (with select)
		
				syntax: SELECT column-list
					FROM table_name
					[WHERE condition]
					[ORDER BY column1, column2, .. columnN] [ASC | DESC];
					or
					ORDER BY sort_expresssion [ASC | DESC] [NULLS FIRST | NULLS LAST]  
					
				e.g.    select id, name from teachers order by department desc;
				
				
				
		21.6) LIMIT - used to limit the data amount returned by the SELECT statement.
		
				SYNTAX: SELECT column1, column2, columnN
					FROM table_name
					LIMIT [no of rows]
									
				
			i) without limit: 	 mydatabase=# select * from teachers ;
						 id |    name    | department | working_year | salary | bonus | gender 
						----+------------+------------+--------------+--------+-------+--------
						  1 | Manoj      | Science    |           20 |  50000 | 25000 | M
						  2 | Manoj      | Math       |           20 |  50000 | 25000 | M
						  4 | Ram        | Medical    |           25 |  35000 | 20000 | M
						  3 | ritu       | Math       |           10 |  10000 |  1000 | F
						  5 | Manju dass | Math       |           10 |  10000 |  1000 | F
						(5 rows)

			ii) Limit 		mydatabase=# select * from teachers limit 3;
						 id | name  | department | working_year | salary | bonus | gender 
						----+-------+------------+--------------+--------+-------+--------
						  1 | Manoj | Science    |           20 |  50000 | 25000 | M
						  2 | Manoj | Math       |           20 |  50000 | 25000 | M
						  4 | Ram   | Medical    |           25 |  35000 | 20000 | M
						(3 rows)

		     iii) Limit with order by	 mydatabase=# select * from teachers order by id limit 4;
						 id | name  | department | working_year | salary | bonus | gender 
						----+-------+------------+--------------+--------+-------+--------
						  1 | Manoj | Science    |           20 |  50000 | 25000 | M
						  2 | Manoj | Math       |           20 |  50000 | 25000 | M
						  3 | ritu  | Math       |           10 |  10000 |  1000 | F
						  4 | Ram   | Medical    |           25 |  35000 | 20000 | M
						(4 rows)


		     iv) Limit with offset 	 mydatabase=# select * from teachers order by id limit 2 offset 2;
			 (skip rows) 		 id | name | department | working_year | salary | bonus | gender 
						----+------+------------+--------------+--------+-------+--------
						  3 | ritu | Math       |           10 |  10000 |  1000 | F
						  4 | Ram  | Medical    |           25 |  35000 | 20000 | M
						(2 rows)
						
						
						
						
		21.7) FETCH - To retrieve a number of rows returned by a query same as limit but follow sql standard.
			      (OFFSET clause must come before the FETCH clause in SQL:2008. However, OFFSET and FETCH clauses can appear 					in any order in PostgreSQL.)
		
				syntax:     OFFSET start { ROW | ROWS }  
    					    FETCH { FIRST | NEXT } [ row_count ] { ROW | ROWS } ONLY  
				
				
				
		 i) Without fetch		mydatabase=# select * from teachers ;
						 id |    name    | department | working_year | salary | bonus | gender 
						----+------------+------------+--------------+--------+-------+--------
						  1 | Manoj      | Science    |           20 |  50000 | 25000 | M
						  2 | Manoj      | Math       |           20 |  50000 | 25000 | M
						  4 | Ram        | Medical    |           25 |  35000 | 20000 | M
						  3 | ritu       | Math       |           10 |  10000 |  1000 | F
						  5 | Manju dass | Math       |           10 |  10000 |  1000 | F
						(5 rows)

		ii) Fetch first first row-		mydatabase=# select * from teachers FETCH FIRST ROW ONLY;
						 id | name  | department | working_year | salary | bonus | gender 
						----+-------+------------+--------------+--------+-------+--------
						  1 | Manoj | Science    |           20 |  50000 | 25000 | M
						(1 row)

		iii) Fetch first 1 rows orrow mydatabase=# select * from teachers FETCH FIRST 1 ROWS ONLY;
						 id | name  | department | working_year | salary | bonus | gender 
						----+-------+------------+--------------+--------+-------+--------
						  1 | Manoj | Science    |           20 |  50000 | 25000 | M
						(1 row)

		iv) Fetch first 4 row or rows   mydatabase=# select * from teachers FETCH FIRST 4 ROWS ONLY;
						 id | name  | department | working_year | salary | bonus | gender 
						----+-------+------------+--------------+--------+-------+--------
						  1 | Manoj | Science    |           20 |  50000 | 25000 | M
						  2 | Manoj | Math       |           20 |  50000 | 25000 | M
						  4 | Ram   | Medical    |           25 |  35000 | 20000 | M
						  3 | ritu  | Math       |           10 |  10000 |  1000 | F
						(4 rows)

		v) Fetch with offset		mydatabase=# select * from teachers OFFSET 2 ROWS FETCH FIRST 2 ROWS ONLY;
						 id | name | department | working_year | salary | bonus | gender 
						----+------+------------+--------------+--------+-------+--------
						  4 | Ram  | Medical    |           25 |  35000 | 20000 | M
						  3 | ritu | Math       |           10 |  10000 |  1000 | F
						(2 rows)

            vi) Fetch with order by 		 mydatabase=# select * from teachers ORDER BY ID OFFSET 2 ROWS FETCH FIRST 2 ROWS ONLY;
		and offset			 id | name | department | working_year | salary | bonus | gender 
						----+------+------------+--------------+--------+-------+--------
						  3 | ritu | Math       |           10 |  10000 |  1000 | F
						  4 | Ram  | Medical    |           25 |  35000 | 20000 | M
						(2 rows)

									
		
			
			
			
---------------------------------------OPERATORS------------------------------------------------------

1)  Logical Operators : AND, OR, NOT

	1.1)  AND- allows the existence of multiple conditions in a PostgresSQL statement's WHERE clause. (Both condition need true)
	
			SYNTAX: mydatabase=# select * from teachers where id=5 and name='Manju dass';
				 id |    name    | department | working_year | salary | bonus | gender 
				----+------------+------------+--------------+--------+-------+--------
				  5 | Manju dass | Math       |           10 |  10000 |  1000 | F
				(1 row)
	
	1.2) OR- The OR operator is used to combine multiple conditions in a PostgresSQL statement's WHERE clause. (any one true)

			SYNTAX: mydatabase=# SELECT * FROM teachers where id=5 or name='Manoj';
				 id |    name    | department | working_year | salary | bonus | gender 
				----+------------+------------+--------------+--------+-------+--------
				  1 | Manoj      | Science    |           20 |  50000 | 25000 | M
				  2 | Manoj      | Math       |           20 |  50000 | 25000 | M
				  5 | Manju dass | Math       |           10 |  10000 |  1000 | F
				(3 rows)
				
				
	1.3) NOT- The NOT operator reverses the meaning of the logical operator with which it is used. Eg. NOT EXISTS, NOT BETWEEN, NOT 				IN etc. This is negate operator.

			Table:  mydatabase=# select * from teachers ;
				 id |    name    | department | working_year | salary | bonus | gender 
				----+------------+------------+--------------+--------+-------+--------
				  1 | Manoj      | Science    |           20 |  50000 | 25000 | M
				  2 | Manoj      | Math       |           20 |  50000 | 25000 | M
				  4 | Ram        | Medical    |           25 |  35000 | 20000 | M
				  3 | ritu       | Math       |           10 |  10000 |  1000 | F
				  5 | Manju dass | Math       |           10 |  10000 |  1000 | F
				  6 | rahul      | non-med    |            1 |  50000 |  5000 | M
				(6 rows)

		  	NOT IN: mydatabase=# select * from teachers where name not in ('Manoj','rahul');
				 id |    name    | department | working_year | salary | bonus | gender 
				----+------------+------------+--------------+--------+-------+--------
				  4 | Ram        | Medical    |           25 |  35000 | 20000 | M
				  3 | ritu       | Math       |           10 |  10000 |  1000 | F
				  5 | Manju dass | Math       |           10 |  10000 |  1000 | F
				(3 rows)
				
				
2) Comparison Operators : 

			Operators 	       		 Description
			-------------------------------------------------------------------------------------------------------
			< ( less than) 			Returns true when the left operand is less than the right operand.
			> ( greater than) 			Returns true when the left operand is greater than the right operand.
			<= ( less than or equal ) 		Returns true when the left operand is less than or equal to the right 																operand.
			>= (greater than or equal) 		Returns true when the left operand is greater than or equal to the right 																	operand.
			= ( equal ) 				Returns true when the operands are equal but the type of the operands must 																	be same.
			<> or != ( not equal) 			Returns true when the operands are not equa
		
		
3) Arithmetic Operators: 

			   Operators 			Description 				Example 		Output
			   ------------------------------------------------------------------------------------------------
				+ 			Addition 				5 + 8 			13
				- 			Subtraction 				6 - 9 			-3
				* 			Multiplication 			5 * 8 			40
				/ 			Division 				15 / 3 		5
				% 			Modulo ( Remainder ) 			15 % 2 		1
				^ 			Exponentiation 			4.0 ^ 2.0 		16
				| / 			Square Root 				|/ 16 		4
				| | / 			Cube Root 				||/ 27 		3
				! 			Factorial 				!6 			720
				! ! 			Factorial ( with prefix operator) 	!!6 			720
				@ 			Absolute Value 			@-15.07 		15.07
				& 			Bitwise AND 				53 & 38 		36
				| 			Bitwise OR 				53 | 38 		55
				# 			Bitwise XOR 				53 # 38 		19
				~ 			Bitwise NOT 				~ 38 			-39
				<< 			Bitwise shift left 			25 << 2 		100
				>> 			Bitwise shift right 			120 >> 3 		15
				
4) LIKE - returns true if the string matches the supplied pattern. and the NOT LIKE expression returns false if LIKE returns true.

		I) % -  matches any sequence of zero or more characters.
		
			SYNTAX: mydatabase=# select * from teachers where name like 'M%';
				 id |    name    | department | working_year | salary | bonus | gender 
				----+------------+------------+--------------+--------+-------+--------
				  1 | Manoj      | Science    |           20 |  50000 | 25000 | M
				  2 | Manoj      | Math       |           20 |  50000 | 25000 | M
				  5 | Manju dass | Math       |           10 |  10000 |  1000 | F
				(3 rows)

		
		II) _ -  pattern stands for (matches) any single character
		
			SYNTAX: mydatabase=# select * from teachers where name LIKE '_a%';
				 id |    name    | department | working_year | salary | bonus | gender 
				----+------------+------------+--------------+--------+-------+--------
				  1 | Manoj      | Science    |           20 |  50000 | 25000 | M
				  2 | Manoj      | Math       |           20 |  50000 | 25000 | M
				  4 | Ram        | Medical    |           25 |  35000 | 20000 | M
				  5 | Manju dass | Math       |           10 |  10000 |  1000 | F
				  6 | rahul      | non-med    |            1 |  50000 |  5000 | M
				(5 rows)

		III) NOT LIKE-  mydatabase=# select * from teachers where name NOT LIKE '_a%';
				 id | name | department | working_year | salary | bonus | gender 
				----+------+------------+--------------+--------+-------+--------
				  3 | ritu | Math       |           10 |  10000 |  1000 | F
				(1 row)

		
5) Bit Operators: 

			     Operator 		         Description
			    -----------------------------------------
				|| 			concatenation
				& 			bitwise AND
				| 			bitwise OR
				# 			bitwise XOR
				~ 			bitwise NOT
				<< 			bitwise shift left
				>> 			bitwise shift right	
				
		e.g. -  mydatabase=# select 'deep'||'dobhal' as concatenate;
					 concatenate 
					-------------
					 deepdobhal
					(1 row)

6) BETWEEN-  how to retrieve values from an expression within a specific range

		Syntax: mydatabase=# select first_name from emp where emp_id not between or between 1 and 3;
				 first_name 
				------------
				 Manoj     
				 Rahul     
				 Manju     
				 Deepak    
				 Ram       
				(5 rows)
7) UNION - which is used to combine the output of various commands into a single output.

			i)  The number and the order of the columns in the select list of both queries must be the same.
			ii) The data types must be compatible.

			iii) duplicate rows from the combined data set show one time only.
			
			mydatabase=# select * from table_x;
			 f | s 
			---+---
			 1 | 2
			 2 | 4
			 3 | 9
			 3 | 3
			(4 rows)

			mydatabase=# select * from table_y;
			 f1 | s1 
			----+----
			  1 |  1
			  2 |  2
			  3 |  3
			  1 |  2
			(4 rows)

			mydatabase=# select * from table_x
			union
			select * from table_y
			order by columnname;
			 f | s 
			---+---
			 3 | 3
			 3 | 9
			 1 | 2
			 2 | 2
			 1 | 1
			 2 | 4
			(6 rows)
			
	UNION ALL -duplicate rows from the combined data set show two time only.

			mydatabase=# select * from table_x
			union all
			select * from table_y;
			 f | s 
			---+---
			 1 | 2
			 2 | 4
			 3 | 9
			 3 | 3
			 1 | 1
			 2 | 2
			 3 | 3
			 1 | 2
			(8 rows)




9) INTERSECT - used to merge the output of multiple commands common rows.

			mydatabase=# select * from table_x
			mydatabase-# intersect
			mydatabase-# select * from table_y;
			 f | s 
			---+---
			 3 | 3
			 1 | 2
			(2 rows)



10)EXCEPT - show rows from first table which aren't common in IINd table


	
			mydatabase=# select * from table_x
			except
			select * from table_y order by f;
			 f | s 
			---+---
			 2 | 4
			 3 | 9
			(2 rows)











---------------------------------------------------JOINS------------------------------------------------------

It is used to merge columns from one or more tables according to the data of the standard columns between connected tables. Usually, the standard columns of the first table are primary key columns and the second table columns are foreign key columns.

                                     TYPES 
				---------------------		
				    Inner join (Default join so Inner optional)
				    Left join	or Left Outer Join
				    Left join only left table
				    Right join or Right Outer Join
				    Right Join only right table 
				    Full join or Full outer join
				    Full outer join ONLY UNIQUE ROWS FROM BOTH TABLES
				    Cross join 
				    Natural join
				    Self-join.
				    
			Table-set_a-  	 data  			Table- set_b-	 data 	
					------                         		------
					    1						   1
					    2						   2
					    3						   3	
					    5						   8
					(4 rows)   					(4 rows)

	    			    
				 
		I) INNER JOIN - (SET INTERSECTION) - COMMON ELEMENTS FROM SET A AND SER B
			
		syntax: mydatabase=# select A.data as A_data, B.data as B_data from set_a as A inner join set_b as B on A.data=B.data;
		
					a_data | b_data 
					--------+--------
					      1 |      1
					      2 |      2
					      3 |      3
					(3 rows)							 



		
		
		II) Left join	or Left Outer Join  -  Returns all records from the left table (table1), and the 								matching records (if any) from the right table (table2).
		
		syntax: mydatabase=# select A.data as a, B.data as b from set_a as A left join set_b as B on A.data=B.data;
		
						 a | b 
						---+---
						 1 | 1
						 2 | 2
						 3 | 3
						 5 | -
						(4 rows)
						
		III) Left join Only row from left table using where IS NULL : -
			
		syntax: mydatabase=# select * from set_a left join set_b on set_a.data=set_b.data where set_b.data is null;
						 data | data 
						------+------
						    5 |  -   
						(1 row)


		IV) Right join or Right Outer join :   Returns all records from the right table (table1), and the 								  matching records (if any) from the left table (table2).


		syntax: mydatabase=# select * from set_a as A right outer join set_b as B on A.data=B.data;
						 data | data 
						------+------
						    1 |    1
						    2 |    2
						    3 |    3
						   -  |    8
						(4 rows)
						
						
		V) Right join Only row from right table using where IS NULL :

		syntax: mydatabase=# select * from set_a as A right outer join set_b as B on A.data=B.data where set_a.data IS NULL;
						 data | data 
						------+------
						    - |    8
						    
						(4 rows) 
						
		VI) Full outer join - returns a result set that contains all rows from both left and right tables, with the matching rows 						from both sides if available. In case there is no match, the columns of the table will be filled 						with NULL.

		
		syntax: mydatabase=# select * from set_a as A full outer join set_b as B on A.data=B.data;
						 data | data 
						------+------
						    1 |    1
						    2 |    2
						    3 |    3
						    5 |    - 
						   -  |    8
						(5 rows)
						
		VII) Full outer join ONLY UNIQUE(unmatch) ROWS FROM BOTH TABLES :- 
		
			SYNTAX: mydatabase=# select * from a full join b on a.data=b.data where a.data is null or b.data is null;
						 data | data 
						------+------
						    5 |    -  
						    - |    8
						(2 rows)
						
						
		VIII) CROSS JOIN -(CARTESIAN JOIN) that allows us to produce the Cartesian product of all 						related tables.
		
		SYNTAX: mydatabase=# select * from a cross join b;  OR select * from a inner join b on True;
					 data | data 
					------+------
					    1 |    1
					    1 |    2
					    1 |    3
					    1 |    8
					    2 |    1
					    2 |    2
					    2 |    3
					    2 |    8
					    3 |    1
					    3 |    2
					    3 |    3
					    3 |    8
					    5 |    1
					    5 |    2
					    5 |    3
					    5 |    8
					(16 rows)
					
					
		IX) SELF JOIN - i) The PostgreSQL Self Join is Special Join, where we can also get the hierarchical data within the same 																	    table.   
			    ii) We used the PostgreSQL Self join clause to combine a table itself with the help of Inner Join and Left 																    Join clauses.
			syntax: mydatabase=# select * from a as x inner join or left join a as y on x.data=y.data;
						 data | data 
						------+------
						    1 |    1
						    2 |    2
						    3 |    3
						    5 |    5
						(4 rows)

		X) Natural Join :- The natural join is where multiple tables are combined, and as an output, we will get the new rows, 					    which is intended to join the columns for each of the tables		

			syntax: mydatabase=# select * from a natural Join or Natural Inner join b; (
				 data 
				------
				    1
				    2
				    3
				(3 rows)
				
							
						
		
			syntax: mydatabase=# select * from a natural left join b;
				 data 
				------
				    1
				    2
				    3
				    5
				(4 rows)

			syntax: mydatabase=# select * from a natural right join b;
				 data 
				------
				    1
				    2
				    3
				    8
				(4 rows)
				

----------------------------------------------Constraints----------------------------------------

Constraints are the rules enforced on data columns on table. These are used to prevent invalid data from being entered into the 	database				
					    Types
				-----------------------------------
				NOT NULL Constraint − Ensures that a column cannot have NULL value.
				
				CHECK Constraint − The CHECK constraint ensures that all values in a column satisfy certain conditions.

				UNIQUE Constraint − Ensures that all values in a column are different.

				PRIMARY Key − Uniquely identifies each row/record in a database table.

				FOREIGN Key − Constrains data based on columns in other tables.

				EXCLUSION Constraint - This constraint is used to make sure that any two rows are linked on the precise 								columns or statements with the help of defined operators, and one of these operator 							assessments should return either Null or False.
				
				
				
1) NOT NULL -     Syntax:	    CREATE TABLE Customer(  
				    Cust_Id INT PRIMARY KEY NOT NULL,  (Cust_id column can't have null values)
				    Cust_Name TEXT NOT NULL,   
				    Cust_Address CHAR(50),  
				    Cust_Age INT NOT NULL,  
				    Cust_Salary REAL  
				    ); 
				    
		 Note: A NOT NULL constraint is always written as a column constraint. 
				    
				    				
2) CHECK Constraint − The CHECK Constraint enables a condition to check the value being entered into a record. If the condition evaluates 			to false, the record violates the constraint and is not entered into the table.

		    Syntax: 	    mydatabase=# 	create table emp
							(emp_id int not null,
							first_name char(10),
							last_name char(10),
							gender char not null,
							salary real check(salary>5000));
	    
				     mydatabase=# 	insert into emp 
							values(1,'Deepak',Default, 'M',1000);
							ERROR:  new row for relation "emp" violates check constraint "emp_salary_check"
							DETAIL:  Failing row contains (1, Deepak    , null, M, 1000).	
				

3) UNIQUE Constraint − Ensures that all values in a column are different.

		3.1)  As Column Constraint 
			
				Syntax: mydatabase=# alter table emp 
					mydatabase-# add column email varchar(50) UNIQUE;
					
					
		3.2) As Table Constraint (unique constraint on multiple columns)
		
		
		
4) PRIMARY Key - Not Null, Unique, (A primary key is a column or a group of columns used to identify a row uniquely in a table.)


		i) As Column Constraint-	CREATE TABLE TABLE (
						column_1 data_type PRIMARY KEY,
						column_2 data_type,
							…
							);
							
		ii) AS Table Constraint - 	CREATE TABLE TABLE (
						column_1 data_type,
						column_2 data_type,
						… 
						PRIMARY KEY (column_1, column_2)
						);
					
5) Foreign Key - A foreign key is a column or a group of columns in a table that reference the primary key of another 					table.	
 
					CREATE TABLE contacts(
					   contact_id INT GENERATED ALWAYS AS IDENTITY,
					   customer_id INT,
					   contact_name VARCHAR(255) NOT NULL,
					   phone VARCHAR(15),
					   email VARCHAR(100),
					   PRIMARY KEY(contact_id),
					   CONSTRAINT fk_customer   			(name of foreign key)
					   FOREIGN KEY(customer_id) 			(column or columns used for foreign key)
					   REFERENCES customers(customer_id)		(Reference with primary key)
					);			



---------------------------------------INDEX---------------------------------
An index is a separated data structure e.g., B-Tree that speeds up the data retrieval on a table at the cost of additional writes and storage to maintain it. Indexes help the database server find specific rows much faster than it could do without indexes.

1) Index list -  (\di - show index in database)
 
			    SELECT tablename, indexname, indexdef  
			    FROM pg_indexes  
			    WHERE schemaname = 'public'  
			    ORDER BY tablename, indexname;  

2) create index:	    create index index_name 
	






-------------------------------------------------Temporary Table----------------------------------------

A temporary table is a brief table; its name means; it presents at the time of a database session. 

	syntax: CREATE TEMPORARY TABLE temp_table_name(...);  or CREATE TEMP TABLE temp_table_name(...);  
	
	
	
-------------------------------------------------Sub-Quries----------------------------------------------

The query inside the brackets is called a subquery or an inner query. The query that contains the subquery is known as an outer query.

    First, executes the subquery.
    Second, gets the result and passes it to the outer query.
    Third, executes the outer query.
    
    
	

--------------------------------------------------Functions-----------------------------------

1)			     current_date -  return current date
		             
		             e.g. select CURRENT_DATE;
		             
		             now() -         return current date and time
		             now()::date -   return current date only	
		             
		             
		             TO_CHAR()-      get the output in a specific format
		             	
		            e.g. SELECT TO_CHAR(NOW() :: DATE, 'YYYY/MM/DD');   
		            
		            AGE()
		            
		            EXTRACT(),
		            
		           CURRENT_TIME        mydatabase=# select current_time OR CURRENT_TIME(2)
						mydatabase-# ;
						     current_time      
						-----------------------
						 14:26:13.238285+05:30   OR 14:26:13.23
							(1 row)



			    LOCALTIME -     mydatabase=# select LOCALTIME;
							    localtime    
							-----------------
							 14:29:19.097756
							(1 row)

							mydatabase=# select LOCALTIME(2);
							  localtime  
							-------------
							 14:29:25.37
							(1 row)


CURRENT_TIMESTAMP, TIMEOFDAY(), and timezone(zone, timestamp)



SHOW TIMEZONE;   NOW(), CURRENT_TIMESTAMP, CURRENT_TIME, TIMEOFDAY(), converting time value


justify_days(), justify_hours(), justify_interval().


------------------------------------------IMPORTANT FUNCTION--------------------------

1) PostgreSQL COALESCE as ISNULL - PostgreSQL does not have the ISNULL function. However, you can use the COALESCE function which 					provides similar functionality. Note that the COALESCE function returns the first non-null 						argument, so the following syntax has a similar effect as the ISNULL function above: 

			syntax: COALESCE(EXPRESSION,REPLACEMENT)
			
			e.g. inventory_mgt=# select customer_id,coalesce(sum(quantity),0) from customer natural left join customer_order 					group by customer_id order by customer_id;
			
				 customer_id | coalesce 
				-------------+----------
				 CUS001      |        1
				 CUS002      |        1
				 CUS003      |        2
				 CUS004      |        1
				 CUS005      |        2
				 CUS006      |        2
				 CUS007      |        2
				 CUS008      |        4
				 CUS009      |        1
				 CUS010      |        3
				 CUS011      |        0
				 CUS012      |        0
				(12 rows)






--------------------------------------------Important Questions---------------------------------

1) how alter column type into serial?

	mydatabase=# alter table emp
	mydatabase-# alter column emp_id type serial;
	ERROR:  type "serial" does not exist

Solution :     CREATE SEQUENCE my_serial START 5 OWNED BY tablename.columnname;

		ALTER TABLE address ALTER COLUMN columnname SET DEFAULT nextval('my_serial');



2) How to know storge

		  SELECT typname, typlen  
  		  FROM pg_type  
    		  WHERE typname ~ '^timestamp';   




3) second highest salary query: 
	
		
mydatabase=#  select first_name,salary from emp where salary=(select max(salary) from emp where salary <>( select max(salary) from emp));
				 first_name |  salary  
				------------+----------
				 Manju      | 25000.00
				 Ram        | 25000.00
				 Raj        | 25000.00
				(3 rows)





			

		


		
