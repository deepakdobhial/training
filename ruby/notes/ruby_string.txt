-----------------------------------Strings (mutable object)-------------------------
1)
	puts "Hello"
	puts 'Hello'

	---> output: Hello
			 
2) Accessing string elements - 

		a="deep"
		
		a['d']
		
		a[0]
		"d"
		a[1]
		"e"
		a[2]
		"e"
		a[3]
		"p"
		a[4]
		nil
					 
3) Multiline string - 

	1)	puts "   
			A   
			AB   
			ABC   
			ABCD"  
	
	2) puts %/   
			A   
			AB   
			ABC   
			ABCD/
			
	3) puts <<STRING   
			A   
			AB   
			ABC   
			ABCD   
			STRING  
			
			
---------------------------------------Substitution Methods------------------------------------------

	i)sub(pattern, replacement)  - One substitution (or none); returns a new string.
	e.g. 	3.0.0 :021 > a='abcd'
			 => "abcd" 
			3.0.0 :022 > c=a.sub('bc','BC')
			 => "aBCd" 
			3.0.0 :023 > c
			 => "aBCd" 
			 
	e.g.	 3.0.0 :024 > d=a.sub(/[a,b,c,d]/,'*')     #/[a,b,c,d]/ regexp
			 => "*bcd" 
			3.0.0 :025 > d
			 => "*bcd" 

	ii) sub!(pattern, replacement)  - One substitution (or none); returns self.
		
	e.g. 	3.0.0 :026 > c=a.sub!('bc','BC')
			 => "aBCd" 
			3.0.0 :027 > c
			 => "aBCd" 
			3.0.0 :028 > a
			 => "aBCd"
			 
	iii) gsub(pattern, replacement) : Zero or more substitutions; returns a new string.
		
	e.g. 	3.0.0 :040 > a='aaa'
			 => "aaa" 
			3.0.0 :041 > c=a.gsub('a','e')
			 => "eee" 
			3.0.0 :042 > c
			 => "eee" 
			3.0.0 :043 > a
			 => "aaa" 
			 
			3.0.0 :050 > c=a.gsub(/[a,b,c,d,e]/,'i')
 			=> "iii" 
 			
 	iv) gsub!(pattern, replacement) : Zero or more substitutions; returns self.
	
	e.g.    3.0.0 :051 > c=a.gsub!(/[a,b,c,d,e]/,'i')
			 => "iii" 
			3.0.0 :052 > c
			 => "iii" 
			3.0.0 :053 > a
			 => "iii" 
			 
			 3.0.0 :054 > c=a.gsub!(/[a,b,c,d,e]/,'i')
			 => nil 
			3.0.0 :055 > c
			 => nil 
			3.0.0 :056 > c=a.gsub!(/[a,b,c,d,e]/)
			 => #<Enumerator: "iii":gsub!(/[a,b,c,d,e]/)>   #when not pass replacement string
			 
			 
	hash replacement- 		 3.0.0 :058 > h = {'foo' => 'bar', 'baz' => 'bat'}
							 => {"foo"=>"bar", "baz"=>"bat"} 
							3.0.0 :059 > 'food'.sub('foo', h) # => "bard"
							 => "bard" 
							3.0.0 :060 > h
							 => {"foo"=>"bar", "baz"=>"bat"} 
							 

-----------------------------------------------Methods for Creating a String------------------------------------------------------------


Public Class Methods----- 
-------------------------=--------



1)  new(string = '') → new_string
	new(string = '', encoding: encoding) → new_string
	new(string = '', capacity: size) → new_string    #capacity may set the size of the internal buffer, which may affect performance:
	
	3.0.0 :064 > a=String.new
 	=> ""
	
	3.0.0 :062 > a=String.new('Deepak')
	 => "Deepak" 
	3.0.0 :063 > a
	 => "Deepak" 
	 
	 3.0.0 :067 > a.encoding
 => #<Encoding:ASCII-8BIT> 
 
 
	 3.0.0 :072 > a=String.new("deepak",encoding:'UTF-8')
	 => "deepak" 
	3.0.0 :073 > a.encoding
	 => #<Encoding:UTF-8> 
	 

2) try_convert(object) → object, new_string, or nil--

		If object is a String object, returns object.

		Otherwise if object responds to :to_str, calls object.to_str and returns the result.

		Returns nil if object does not respond to :to_str.

		Raises an exception unless object.to_str returns a String object.
		

		3.0.0 :082 > a=String.try_convert('deep')
		 => "deep" 
		 
		3.0.0 :089 > a=String.try_convert([1,2,3])
		 => nil 
		3.0.0 :090 > a
		 => nil 
		 
		 
--------------------------------------------------------Methods for Querying--------------------------------------------------------

1) length → integer---Returns the count of characters (not bytes) in self:

	3.0.0 :107 > "\x67\u3025".bytesize
	 => 2	
	
	3.0.0 :097 > a="hello"
	 => "hello" 
	3.0.0 :098 > a.length
	 => 5 
	 
2) size - alias of length

	3.0.0 :099 > a.size
	 => 5 
	 
3)  empty? → true or false- Returns true if the length of self is zero, false otherwise

	3.0.0 :100 > "hee".empty?
	 => false 
	3.0.0 :101 > "".empty?
	 => true 

4)  bytesize → integer- Returns the count of bytes in self

	 3.0.0 :107 > "\x67\u3025".bytesize
	 => 4 

5) count([other_str]+) → integer-Returns the count of substrings matching given strings.

	3.0.0 :037 > a='hello world'
	 => "hello world" 
	3.0.0 :038 > a.count 'lo'          #counts the number of times the characters 'l' and 'o' appear in the string
	 => 5 


	3.0.0 :044 > a.count "lo", "o"  # count intersection of the 2 parameters('lo' & 'o') passed to it.
	 => 2 
	
	3.0.0 :053 > a.count 'hellor','rl'  # intersction of 'hellor' and 'rl' is 'r' and 'l' appears 'r'=1 and 'l'=3 total= 4
	=> 4 
	
	3.0.0 :058 > a.count 'llo','^l'    # ^l means 'l' will not include in return searched string
 	=> 2 

	3.0.0 :065 > a.count "oj-m"        # occurrence of alphabet 'o' and between j-m ['j','k','l','m']  so o = 2 + l =3 = 5 
	=> 5 
     (this equal to a.count "ol")
     
	3.0.0 :067 > "hello^world".count "\\^aeiou"   # backslashes negates the '^' characters  so aeiou matches e,o and ^ matches ^
	=> 4											e=1, o=2, ^=1  total = 4
	
	
	3.0.0 :068 > "hello-world".count "a\\-eo"    # backslashes negates the '-' characters so a,-,e,o matches -=1, e=1, o=2 total=4
	 => 4
	 
	3.0.0 :069 > c = "hello world\\r\\n"        
	 => "hello world\\r\\n" 
	3.0.0 :070 > c.count "\\"                   # first backslashes negates second. so \\=2 
	=> 2 
 

	




