-----------------------------------Strings (mutable object)-------------------------
1)
	puts "Hello"
	puts 'Hello'

	---> output: Hello
			 
2) Accessing string elements - 

		a="deep"
		
		a['d']
		
		a[0]
		"d"
		a[1]
		"e"
		a[2]
		"e"
		a[3]
		"p"
		a[4]
		nil
					 
3) Multiline string - 

	1)	puts "   
			A   
			AB   
			ABC   
			ABCD"  
	
	2) puts %/   
			A   
			AB   
			ABC   
			ABCD/
			
	3) puts <<STRING   
			A   
			AB   
			ABC   
			ABCD   
			STRING  
			
			
---------------------------------------Substitution Methods------------------------------------------

	i)sub(pattern, replacement)  - One substitution (or none); returns a new string.
	e.g. 	3.0.0 :021 > a='abcd'
			 => "abcd" 
			3.0.0 :022 > c=a.sub('bc','BC')
			 => "aBCd" 
			3.0.0 :023 > c
			 => "aBCd" 
			 
	e.g.	 3.0.0 :024 > d=a.sub(/[a,b,c,d]/,'*')     #/[a,b,c,d]/ regexp
			 => "*bcd" 
			3.0.0 :025 > d
			 => "*bcd" 

	ii) sub!(pattern, replacement)  - One substitution (or none); returns self.
		
	e.g. 	3.0.0 :026 > c=a.sub!('bc','BC')
			 => "aBCd" 
			3.0.0 :027 > c
			 => "aBCd" 
			3.0.0 :028 > a
			 => "aBCd"
			 
	iii) gsub(pattern, replacement) : Zero or more substitutions; returns a new string.
		
	e.g. 	3.0.0 :040 > a='aaa'
			 => "aaa" 
			3.0.0 :041 > c=a.gsub('a','e')
			 => "eee" 
			3.0.0 :042 > c
			 => "eee" 
			3.0.0 :043 > a
			 => "aaa" 
			 
			3.0.0 :050 > c=a.gsub(/[a,b,c,d,e]/,'i')
 			=> "iii" 
 			
 	iv) gsub!(pattern, replacement) : Zero or more substitutions; returns self.
	
	e.g.    3.0.0 :051 > c=a.gsub!(/[a,b,c,d,e]/,'i')
			 => "iii" 
			3.0.0 :052 > c
			 => "iii" 
			3.0.0 :053 > a
			 => "iii" 
			 
			 3.0.0 :054 > c=a.gsub!(/[a,b,c,d,e]/,'i')
			 => nil 
			3.0.0 :055 > c
			 => nil 
			3.0.0 :056 > c=a.gsub!(/[a,b,c,d,e]/)
			 => #<Enumerator: "iii":gsub!(/[a,b,c,d,e]/)>   #when not pass replacement string
			 
			 
	hash replacement- 		 3.0.0 :058 > h = {'foo' => 'bar', 'baz' => 'bat'}
							 => {"foo"=>"bar", "baz"=>"bat"} 
							3.0.0 :059 > 'food'.sub('foo', h) # => "bard"
							 => "bard" 
							3.0.0 :060 > h
							 => {"foo"=>"bar", "baz"=>"bat"} 
							 

-----------------------------------------------Methods for Creating a String------------------------------------------------------------


Public Class Methods----- 
-------------------------=--------



1)  new(string = '') → new_string
	new(string = '', encoding: encoding) → new_string
	new(string = '', capacity: size) → new_string    #capacity may set the size of the internal buffer, which may affect performance:
	
	3.0.0 :064 > a=String.new
 	=> ""
	
	3.0.0 :062 > a=String.new('Deepak')
	 => "Deepak" 
	3.0.0 :063 > a
	 => "Deepak" 
	 
	 3.0.0 :067 > a.encoding
 => #<Encoding:ASCII-8BIT> 
 
 
	 3.0.0 :072 > a=String.new("deepak",encoding:'UTF-8')
	 => "deepak" 
	3.0.0 :073 > a.encoding
	 => #<Encoding:UTF-8> 
	 

2) try_convert(object) → object, new_string, or nil--

		If object is a String object, returns object.

		Otherwise if object responds to :to_str, calls object.to_str and returns the result.

		Returns nil if object does not respond to :to_str.

		Raises an exception unless object.to_str returns a String object.
		

		3.0.0 :082 > a=String.try_convert('deep')
		 => "deep" 
		 
		3.0.0 :089 > a=String.try_convert([1,2,3])
		 => nil 
		3.0.0 :090 > a
		 => nil 
		 
		 
--------------------------------------------------------Methods for Querying--------------------------------------------------------

1) length → integer---Returns the count of characters (not bytes) in self:

	3.0.0 :107 > "\x67\u3025".bytesize
	 => 2	
	
	3.0.0 :097 > a="hello"
	 => "hello" 
	3.0.0 :098 > a.length
	 => 5 
	 
2) size - alias of length

	3.0.0 :099 > a.size
	 => 5 
	 
3)  empty? → true or false- Returns true if the length of self is zero, false otherwise

	3.0.0 :100 > "hee".empty?
	 => false 
	3.0.0 :101 > "".empty?
	 => true 

4)  bytesize → integer- Returns the count of bytes in self

	 3.0.0 :107 > "\x67\u3025".bytesize
	 => 4 

5) count([other_str]+) → integer-Returns the count of substrings matching given strings.

	3.0.0 :037 > a='hello world'
	 => "hello world" 
	3.0.0 :038 > a.count 'lo'          #counts the number of times the characters 'l' and 'o' appear in the string
	 => 5 


	3.0.0 :044 > a.count "lo", "o"  # count intersection of the 2 parameters('lo' & 'o') passed to it.
	 => 2 
	
	3.0.0 :053 > a.count 'hellor','rl'  # intersction of 'hellor' and 'rl' is 'r' and 'l' appears 'r'=1 and 'l'=3 total= 4
	=> 4 
	
	3.0.0 :058 > a.count 'llo','^l'    # ^l means 'l' will not include in return searched string
 	=> 2 

	3.0.0 :065 > a.count "oj-m"        # occurrence of alphabet 'o' and between j-m ['j','k','l','m']  so o = 2 + l =3 = 5 
	=> 5 
     (this equal to a.count "ol")
     
	3.0.0 :067 > "hello^world".count "\\^aeiou"   # backslashes negates the '^' characters  so aeiou matches e,o and ^ matches ^
	=> 4											e=1, o=2, ^=1  total = 4
	
	
	3.0.0 :068 > "hello-world".count "a\\-eo"    # backslashes negates the '-' characters so a,-,e,o matches -=1, e=1, o=2 total=4
	 => 4
	 
	3.0.0 :069 > c = "hello world\\r\\n"        
	 => "hello world\\r\\n" 
	3.0.0 :070 > c.count "\\"                   # first backslashes negates second. so \\=2 
	=> 2 
 

-------------------------------------sub-strings----------------------------------
1) =~  --  Returns the index no. of the first substring that matches a given Regexp or other object; returns nil if no match is found
	
	a='hello world'
	
	3.0.0 :102 > a=~/d/  		#  d found at index no 10
	=> 10 

	3.0.0 :103 > a=~/m/			# m not found
	 => nil 

2)  index(substring, offset = 0) → integer or nil 
	index(regexp, offset = 0) → integer or nil - Returns the index no of the first occurrence of a given substring; returns nil if none 																																	found.
	
	3.0.0 :115 > a.index('o')
	 => 4 
	3.0.0 :117 > a.index(/ll/)
	 => 2 
	3.0.0 :118 > a.index(/rl/)
	 => 8 
	3.0.0 :119 > a.index(/r/)
	 => 8 
	3.0.0 :120 > a.index(/rm/)
	 => nil 
	3.0.0 :121 > a.index(/w/)
	 => 6 
	 
3)  rindex(substring, offset = self.length) → integer or nil
	rindex(regexp, offset = self.length) → integer or nil - Returns the index of the last occurrence of a given substring; returns nil 																														if none found.
	a='hello world'
	
	3.0.0 :123 > a.rindex('l')   # index no of last occurrence of 'l' 
	=> 9
	
	 3.0.0 :125 > a
	 => "hello world" 
	3.0.0 :126 > a.rindex(/rl/)   # index no of last occurrence of 'rl' 
	 => 8 

	3.0.0 :127 > a.rindex(/rm/)
	 => nil 
	 

4) include? other_string → true or false - Returns true if the string contains a given substring; false otherwise.

	3.0.0 :128'> a.include? 'h'
	 => true 
	3.0.0 :129 > a.include? 'm'
	 => false 	
	 
	a.include? /r/  # only strings pass
	
5)  match(pattern, offset = 0) → matchdata or nil click to toggle source
	match(pattern, offset = 0) {|matchdata| ... } → object 

	-----> Returns a MatchData object if the string matches a given Regexp; nil otherwise.
	
	3.0.0 :132 > a
	 => "hello world" 
	3.0.0 :133 > a.match('ll')
	 => #<MatchData "ll"> 

	3.0.0 :134 > a.match('ml')
	 => nil 
	 
	3.0.0 :136 > a.match('h',1)    # Match after index no 1 hence nil return
	 => nil 
	 
	3.0.0 :138 > a.match(/h/) {|matchdata| matchdata }
	 => #<MatchData "h"> 
	 
6) match?(pattern, offset = 0) → true or false - Returns true if the string matches a given Regexp; false otherwise.

	3.0.0 :139 > a.match?(/ll/)
	 => true 
	3.0.0 :140 > a.match?('l')
	 => true 
	3.0.0 :141 > a.match?('ll')
	 => true 
	3.0.0 :142 > a.match?('l',8)
	 => true 
	3.0.0 :143 > a.match?('l',9)
	 => true 
	3.0.0 :144 > a.match?('l',10)
	 => false 

7) start_with?([prefixes]+) → true or false- Returns true if str starts with one of the prefixes given. Each of the prefixes should be a 												 String or a Regexp.


	3.0.0 :147 > a.start_with?('ll')
	 => false 
	3.0.0 :148 > a.start_with?('hel')
	 => true 
	3.0.0 :149 > a.start_with?('he')
	 => true 
	3.0.0 :150/> a.start_with?(/he/)
	 => true 
	3.0.0 :151 > a.start_with?(/ml/)
	 => false

# returns true if one of the prefixes matches.

	3.0.0 :152'> a.start_with?('he','lm')
	 => true 
	3.0.0 :153 > a.start_with?('he','kk')
	 => true 
	3.0.0 :154 > a.start_with?('he','kk','po')
	 => true 
	3.0.0 :155 > a.start_with?('kk','po','pp')
	 => false 
	3.0.0 :156 > a.start_with?('kk','po','he')
	 => true 
	 
8)  end_with?([suffixes]+) → true or false ---Returns true if str ends with one of the suffixes given.

	3.0.0 :157 > a.end_with?('ld')
	 => true 
	3.0.0 :158 > a.end_with?('l')
	 => false 
	 
	3.0.0 :161 > a.end_with?('dl','ml')
	 => false 
	3.0.0 :162 > a.end_with?('ld','ml')
	 => true 
	 
--------------------------------------------Encodings--------------------------------------------------
1) encoding → encoding --Returns the Encoding object that represents the encoding of obj.

	3.0.0 :163 > a.encoding
	 => #<Encoding:UTF-8> 

2)unicode_normalized?(form=:nfc)- Checks whether str is in Unicode normalization form form, which can be any of the four 									  values :nfc, :nfd, :nfkc, or :nfkd. The default is :nfc.

If the string is not in a Unicode Encoding, then an Exception is raised

	3.0.0 :167 > "a\u0300".unicode_normalized? 
	 => false 
	3.0.0 :168 > "a\u0300".unicode_normalized?(:nfd)
	 => true 
	 
3)valid_encoding? → true or false--Returns true for a string which is encoded correctly.
 
	3.0.0 :170 > a.valid_encoding?
	 => true 
	 
4)  ascii_only? → true or false --Returns true for a string which has only ASCII characters.

	3.0.0 :171 > a.ascii_only?
 	=> true 

--------------------------------------------------Others-----------------------------------

1) sum(n=16) → integer # n is optional

	Returns a basic n-bit checksum of the characters in str, where n is the optional Integer parameter, defaulting to 16. The result is 	simply the sum of the binary value of each byte in str modulo 2**n - 1.
	
	3.0.0 :172 > a.sum()
	 => 1116 
	3.0.0 :173 > a.sum(n=16)
	 => 1116 
	3.0.0 :174 > a.sum(n=8)
	 => 92 

2)  hex → integer

	Treats leading characters from str as a string of hexadecimal digits (with an optional sign and an optional 0x) and returns the 	   corresponding number. Zero is returned on error.

	3.0.0 :177 > '0x0a'.hex     # convert into hexadecimal digits (0-9 a-f) a or A = 10....f or F=15
	 => 10 
	3.0.0 :178 > 'a'.hex
	 => 10 
	3.0.0 :179 > 'b'.hex
	 => 11 
	3.0.0 :180 > 'f'.hex
	 => 15 
	3.0.0 :181 > 'g'.hex
	 => 0 
	3.0.0 :182 > 'h'.hex
	 => 0 
	3.0.0 :183 > 'ab'.hex
	 => 171 
	 
	3.0.0 :186 > 'ABC'.hex
 	=> 2748 

----------------------------------------Methods for Comparing----------------------------------------------------
1)  string == object → true or false--Returns true if object has the same length and content; as self; false otherwise:

a='hello world', b='world', c='hello world'

	3.0.0 :187 > a
	 => "hello world" 
	3.0.0 :188 > a==b
	 => false 
	3.0.0 :189 > c='hello world'
	 => "hello world" 
	3.0.0 :190 > a==c
	 => true 
	3.0.0 :191 > a===c
	 => true 
	 
2)  eql?(object) → true or false--Returns true if object has the same length and content; as self; false otherwise:

	3.0.0 :192 > a.eql?b
	 => false 
	3.0.0 :193 > a.eql?c
	 => true 

3)  string <=> other_string → -1, 0, 1, or nil 

	Compares self and other_string, returning:

    -1 if other_string is larger.

    0 if the two are equal.

    1 if other_string is smaller.

    nil if the two are incomparable.
    
    3.0.0 :195 > a<=>c
	 => 0 
	3.0.0 :196 > c<=>b
	 => -1 
	3.0.0 :197 > b<=>c
	 => 1 
	3.0.0 :198 > b<=>5
	 => nil 
	 
4)  casecmp(other_string) → -1, 0, 1, or nil 

	Compares self.downcase and other_string.downcase; returns:

		-1 if other_string.downcase is larger.

		0 if the two are equal.

		1 if other_string.downcase is smaller.

		nil if the two are incomparable.
		
	3.0.0 :201 > a.casecmp(b)
	 => -1 
	3.0.0 :202 > a.casecmp(c)
	 => 0 
	3.0.0 :203 > b.casecmp(c)
	 => 1 
	3.0.0 :204 > c.casecmp(5)
	 => nil 
	3.0.0 :2

5)  casecmp?(other_string) → true, false, or nil - Returns true if self and other_string are equal after Unicode case folding, otherwise false:

	3.0.0 :210 > a.casecmp?(b)
	 => false 

	3.0.0 :212 > a.casecmp?(c)
	 => true 
	3.0.0 :213 > b.casecmp?(c)
	 => false 
	3.0.0 :214 > b.casecmp?(5)
	 => nil 

-----------------------------------------------Methods for Modifying a String-------------------------------------

important note - Each of these methods modifies self.
-----------------------------------------------------

1) Insertion -------->  
	i)  insert(index, other_string) → self-	Inserts the given other_string into self; returns self.
		If the Integer index is positive, inserts other_string at offset index:
		
		b='world'
		
		3.0.0 :215 > b.insert(2,'lsk')
		 => "wolskrld" 
		3.0.0 :216 > b
		 => "wolskrld" 
		 
		 If the Integer index is negative, counts backward from the end of self and inserts other_string at offset index+1 (that is, after self[index]):
		 
		 3.0.0 :217 > b.insert(-2,'abc')
 		=> "wolskrlabcd" 			# insert abc at index -2 
 		
	ii) string << object → string ---Concatenates object to self and returns self:

		3.0.0 :228 > a="hello"
		 => "hello" 
		3.0.0 :229 > b="world"
		 => "world" 
		3.0.0 :230 > a<<" "<<b
		 => "hello world" 
		 
		3.0.0 :235 > a<<65               #concatenates Ascii value of respected integer or code
 		=> "hello worldA" 



2) Substitution -------------
	i) succ! → self - Returns self modified to become its own successor. 
(The first character to be incremented is the rightmost alphanumeric: or, if no alphanumerics, the rightmost character:) 

		a="hello worldA"
		3.0.0 :236 > a.succ!
		 => "hello worldB" 
		3.0.0 :237 > a
		 => "hello worldB" 
		3.0.0 :238 > a.succ!
		 => "hello worldC" 
		3.0.0 :239 > a.succ
		 => "hello worldD" 
		3.0.0 :240 > a
		 => "hello worldC" 
		3.0.0 :241 > a.insert(-1,'1')
		 => "hello worldC1" 
		3.0.0 :242 > a.succ
		 => "hello worldC2" 
		3.0.0 :243 > a.succ!
		 => "hello worldC2" 
		 
	ii) next! - alias to succ! 
		3.0.0 :246 > a.next!
		 => "hello worldC3" 
	
	iii) replace(other_string) → self - Returns self with its entire content replaced by a given string.
	 	3.0.0 :247 > a.replace "hello world"
		 => "hello world" 
		 
	iv) reverse! → self - Returns self with its characters in reverse order.
		3.0.0 :252 > a.reverse!
		 => "dlrow olleh" 
	v) setbyte(index, integer) → integer ---Sets value of ascii code at given index and return ascii code.
		3.0.0 :256 > a
		 => "hello world" 
		3.0.0 :257 > a.setbyte(1,65) 
		 => 65                                  # return ascii code given in argument
		3.0.0 :258 > a
		 => "hAllo world" 						# set ascii value of 65 equal to "A" at index 1 
		 
	vi) tr!(from_str, to_str) → str or nil - Replaces specified characters in self with specified replacement characters; returns self 									if any changes, nil otherwise.
		3.0.0 :263 > d="hello"
		 => "hello" 
		3.0.0 :264 > d.tr!('el','ip')
		 => "hippo" 
		3.0.0 :265 > a
		 => "hAllo world" 
		3.0.0 :266 > d
		 => "hippo" 
		3.0.0 :267 > d.tr!('ip','k')
		 => "hkkko" 
		3.0.0 :268 > d.tr!('k','ell')
		 => "heeeo" 
		3.0.0 :269 > "hello".tr!('aeiou', 'AA*') 
		 => "hAll*"
		
	vii) tr_s!(from_str, to_str) → str or nil- Replaces specified characters in self with specified replacement characters, removing 										duplicates from the substrings that were modified; returns self if any changes, nil otherwise
	
		3.0.0 :270 > a="hello"
		 => "hello" 
		3.0.0 :271 > a.tr_s!('l','r')
		 => "hero" 
		3.0.0 :272 > a.tr_s!('er','m')
		 => "hmo" 
		3.0.0 :273 > "hello".tr_s('el', '*') 
		 => "h*o"		 
	
3) Casing----------
	i) capitalize!(*options) → self or nil--Upcases the initial character and downcases all others; returns self if any changes, nil 								   otherwise.
	
		3.0.0 :280 > a
		 => "hello world" 
		3.0.0 :281 > a.capitalize!
		 => "Hello world" 
		3.0.0 :282 > a.capitalize!
		 => nil 

	
	ii) downcase!(*options) → self or nil - Downcases all characters; returns self if any changes, nil otherwise.
	
		3.0.0 :285 > a.downcase!
		 => "hello world" 
		3.0.0 :286 > a
		 => "hello world" 
		 
	iii) upcase!(*options) → self or nil - Upcases the characters in self; returns self if any changes were made, nil otherwise
	
		3.0.0 :290 > a.upcase!
		 => "HELLO WORLD" 
		3.0.0 :291 > a
		 => "HELLO WORLD" 
		
	iv) swapcase!(*options) → self or nil - Upcases each lowercase character in self; downcases uppercase character; returns self if any 								  changes were made, nil otherwise:
	
		3.0.0 :294 > a.swapcase!
		 => "hello world" 
		3.0.0 :295 > a
		 => "hello world" 	

	

