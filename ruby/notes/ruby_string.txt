-----------------------------------Strings (mutable object)-------------------------
1)
	puts "Hello"
	puts 'Hello'

	---> output: Hello
			 
2) Accessing string elements - 

		a="deep"
		
		a['d']
		
		a[0]
		"d"
		a[1]
		"e"
		a[2]
		"e"
		a[3]
		"p"
		a[4]
		nil
					 
3) Multiline string - 

	1)	puts "   
			A   
			AB   
			ABC   
			ABCD"  
	
	2) puts %/   
			A   
			AB   
			ABC   
			ABCD/
			
	3) puts <<STRING   
			A   
			AB   
			ABC   
			ABCD   
			STRING  
			
			
---------------------------------------Substitution Methods------------------------------------------

	i)sub(pattern, replacement)  - One substitution (or none); returns a new string.
	e.g. 	3.0.0 :021 > a='abcd'
			 => "abcd" 
			3.0.0 :022 > c=a.sub('bc','BC')
			 => "aBCd" 
			3.0.0 :023 > c
			 => "aBCd" 
			 
	e.g.	 3.0.0 :024 > d=a.sub(/[a,b,c,d]/,'*')     #/[a,b,c,d]/ regexp
			 => "*bcd" 
			3.0.0 :025 > d
			 => "*bcd" 

	ii) sub!(pattern, replacement)  - One substitution (or none); returns self.
		
	e.g. 	3.0.0 :026 > c=a.sub!('bc','BC')
			 => "aBCd" 
			3.0.0 :027 > c
			 => "aBCd" 
			3.0.0 :028 > a
			 => "aBCd"
			 
	iii) gsub(pattern, replacement) : Zero or more substitutions; returns a new string.
		
	e.g. 	3.0.0 :040 > a='aaa'
			 => "aaa" 
			3.0.0 :041 > c=a.gsub('a','e')
			 => "eee" 
			3.0.0 :042 > c
			 => "eee" 
			3.0.0 :043 > a
			 => "aaa" 
			 
			3.0.0 :050 > c=a.gsub(/[a,b,c,d,e]/,'i')
 			=> "iii" 
 			
 	iv) gsub!(pattern, replacement) : Zero or more substitutions; returns self.
	
	e.g.    3.0.0 :051 > c=a.gsub!(/[a,b,c,d,e]/,'i')
			 => "iii" 
			3.0.0 :052 > c
			 => "iii" 
			3.0.0 :053 > a
			 => "iii" 
			 
			 3.0.0 :054 > c=a.gsub!(/[a,b,c,d,e]/,'i')
			 => nil 
			3.0.0 :055 > c
			 => nil 
			3.0.0 :056 > c=a.gsub!(/[a,b,c,d,e]/)
			 => #<Enumerator: "iii":gsub!(/[a,b,c,d,e]/)>   #when not pass replacement string
			 
			 
	hash replacement- 		 3.0.0 :058 > h = {'foo' => 'bar', 'baz' => 'bat'}
							 => {"foo"=>"bar", "baz"=>"bat"} 
							3.0.0 :059 > 'food'.sub('foo', h) # => "bard"
							 => "bard" 
							3.0.0 :060 > h
							 => {"foo"=>"bar", "baz"=>"bat"} 
							 

-----------------------------------------------Methods for Creating a String------------------------------------------------------------


Public Class Methods----- 
-------------------------=--------



1)  new(string = '') → new_string
	new(string = '', encoding: encoding) → new_string
	new(string = '', capacity: size) → new_string    #capacity may set the size of the internal buffer, which may affect performance:
	
	3.0.0 :064 > a=String.new
 	=> ""
	
	3.0.0 :062 > a=String.new('Deepak')
	 => "Deepak" 
	3.0.0 :063 > a
	 => "Deepak" 
	 
	 3.0.0 :067 > a.encoding
 => #<Encoding:ASCII-8BIT> 
 
 
	 3.0.0 :072 > a=String.new("deepak",encoding:'UTF-8')
	 => "deepak" 
	3.0.0 :073 > a.encoding
	 => #<Encoding:UTF-8> 
	 

2) try_convert(object) → object, new_string, or nil--

		If object is a String object, returns object.

		Otherwise if object responds to :to_str, calls object.to_str and returns the result.

		Returns nil if object does not respond to :to_str.

		Raises an exception unless object.to_str returns a String object.
		

		3.0.0 :082 > a=String.try_convert('deep')
		 => "deep" 
		 
		3.0.0 :089 > a=String.try_convert([1,2,3])
		 => nil 
		3.0.0 :090 > a
		 => nil 
		 
		 
--------------------------------------------------------Methods for Querying--------------------------------------------------------

1) length → integer---Returns the count of characters (not bytes) in self:

	3.0.0 :107 > "\x67\u3025".bytesize
	 => 2	
	
	3.0.0 :097 > a="hello"
	 => "hello" 
	3.0.0 :098 > a.length
	 => 5 
	 
2) size - alias of length

	3.0.0 :099 > a.size
	 => 5 
	 
3)  empty? → true or false- Returns true if the length of self is zero, false otherwise

	3.0.0 :100 > "hee".empty?
	 => false 
	3.0.0 :101 > "".empty?
	 => true 

4)  bytesize → integer- Returns the count of bytes in self

	 3.0.0 :107 > "\x67\u3025".bytesize
	 => 4 

5) count([other_str]+) → integer-Returns the count of substrings matching given strings.

	3.0.0 :037 > a='hello world'
	 => "hello world" 
	3.0.0 :038 > a.count 'lo'          #counts the number of times the characters 'l' and 'o' appear in the string
	 => 5 


	3.0.0 :044 > a.count "lo", "o"  # count intersection of the 2 parameters('lo' & 'o') passed to it.
	 => 2 
	
	3.0.0 :053 > a.count 'hellor','rl'  # intersction of 'hellor' and 'rl' is 'r' and 'l' appears 'r'=1 and 'l'=3 total= 4
	=> 4 
	
	3.0.0 :058 > a.count 'llo','^l'    # ^l means 'l' will not include in return searched string
 	=> 2 

	3.0.0 :065 > a.count "oj-m"        # occurrence of alphabet 'o' and between j-m ['j','k','l','m']  so o = 2 + l =3 = 5 
	=> 5 
     (this equal to a.count "ol")
     
	3.0.0 :067 > "hello^world".count "\\^aeiou"   # backslashes negates the '^' characters  so aeiou matches e,o and ^ matches ^
	=> 4											e=1, o=2, ^=1  total = 4
	
	
	3.0.0 :068 > "hello-world".count "a\\-eo"    # backslashes negates the '-' characters so a,-,e,o matches -=1, e=1, o=2 total=4
	 => 4
	 
	3.0.0 :069 > c = "hello world\\r\\n"        
	 => "hello world\\r\\n" 
	3.0.0 :070 > c.count "\\"                   # first backslashes negates second. so \\=2 
	=> 2 
 

-------------------------------------sub-strings----------------------------------
1) =~  --  Returns the index no. of the first substring that matches a given Regexp or other object; returns nil if no match is found
	
	a='hello world'
	
	3.0.0 :102 > a=~/d/  		#  d found at index no 10
	=> 10 

	3.0.0 :103 > a=~/m/			# m not found
	 => nil 

2)  index(substring, offset = 0) → integer or nil 
	index(regexp, offset = 0) → integer or nil - Returns the index no of the first occurrence of a given substring; returns nil if none 																																	found.
	
	3.0.0 :115 > a.index('o')
	 => 4 
	3.0.0 :117 > a.index(/ll/)
	 => 2 
	3.0.0 :118 > a.index(/rl/)
	 => 8 
	3.0.0 :119 > a.index(/r/)
	 => 8 
	3.0.0 :120 > a.index(/rm/)
	 => nil 
	3.0.0 :121 > a.index(/w/)
	 => 6 
	 
3)  rindex(substring, offset = self.length) → integer or nil
	rindex(regexp, offset = self.length) → integer or nil - Returns the index of the last occurrence of a given substring; returns nil 																														if none found.
	a='hello world'
	
	3.0.0 :123 > a.rindex('l')   # index no of last occurrence of 'l' 
	=> 9
	
	 3.0.0 :125 > a
	 => "hello world" 
	3.0.0 :126 > a.rindex(/rl/)   # index no of last occurrence of 'rl' 
	 => 8 

	3.0.0 :127 > a.rindex(/rm/)
	 => nil 
	 

4) include? other_string → true or false - Returns true if the string contains a given substring; false otherwise.

	3.0.0 :128'> a.include? 'h'
	 => true 
	3.0.0 :129 > a.include? 'm'
	 => false 	
	 
	a.include? /r/  # only strings pass
	
5)  match(pattern, offset = 0) → matchdata or nil click to toggle source
	match(pattern, offset = 0) {|matchdata| ... } → object 

	-----> Returns a MatchData object if the string matches a given Regexp; nil otherwise.
	
	3.0.0 :132 > a
	 => "hello world" 
	3.0.0 :133 > a.match('ll')
	 => #<MatchData "ll"> 

	3.0.0 :134 > a.match('ml')
	 => nil 
	 
	3.0.0 :136 > a.match('h',1)    # Match after index no 1 hence nil return
	 => nil 
	 
	3.0.0 :138 > a.match(/h/) {|matchdata| matchdata }
	 => #<MatchData "h"> 
	 
6) match?(pattern, offset = 0) → true or false - Returns true if the string matches a given Regexp; false otherwise.

	3.0.0 :139 > a.match?(/ll/)
	 => true 
	3.0.0 :140 > a.match?('l')
	 => true 
	3.0.0 :141 > a.match?('ll')
	 => true 
	3.0.0 :142 > a.match?('l',8)
	 => true 
	3.0.0 :143 > a.match?('l',9)
	 => true 
	3.0.0 :144 > a.match?('l',10)
	 => false 

7) start_with?([prefixes]+) → true or false- Returns true if str starts with one of the prefixes given. Each of the prefixes should be a 												 String or a Regexp.


	3.0.0 :147 > a.start_with?('ll')
	 => false 
	3.0.0 :148 > a.start_with?('hel')
	 => true 
	3.0.0 :149 > a.start_with?('he')
	 => true 
	3.0.0 :150/> a.start_with?(/he/)
	 => true 
	3.0.0 :151 > a.start_with?(/ml/)
	 => false

# returns true if one of the prefixes matches.

	3.0.0 :152'> a.start_with?('he','lm')
	 => true 
	3.0.0 :153 > a.start_with?('he','kk')
	 => true 
	3.0.0 :154 > a.start_with?('he','kk','po')
	 => true 
	3.0.0 :155 > a.start_with?('kk','po','pp')
	 => false 
	3.0.0 :156 > a.start_with?('kk','po','he')
	 => true 
	 
8)  end_with?([suffixes]+) → true or false ---Returns true if str ends with one of the suffixes given.

	3.0.0 :157 > a.end_with?('ld')
	 => true 
	3.0.0 :158 > a.end_with?('l')
	 => false 
	 
	3.0.0 :161 > a.end_with?('dl','ml')
	 => false 
	3.0.0 :162 > a.end_with?('ld','ml')
	 => true 
	 







